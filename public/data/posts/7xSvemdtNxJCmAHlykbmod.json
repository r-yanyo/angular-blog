{
  "id": "7xSvemdtNxJCmAHlykbmod",
  "title": "html新要素「portals」による新しい無限スクロール",
  "date": "2019-05-19",
  "tags": [
    "html",
    "chrome-extension",
    "portals"
  ],
  "content": "<p>Qiitaに挙げた記事です。　<a href=\"https://qiita.com/r-yanyo/items/f9907163bf2ac23f08cb\">https://qiita.com/r-yanyo/items/f9907163bf2ac23f08cb</a></p>\n<h2>動作デモ</h2>\n<p>google検索にて、ページをスクロールすると、次のページが下からニュッっと出てきます。出てきたページをそのままスクロールし続けると、そのページに遷移します。<br><img src=\"https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/176467/9431668f-461a-ecc1-472d-582095684ade.gif\" alt=\"ezgif-5-f94ab8347027.gif\"></p>\n<h2>この記事の目的</h2>\n<p>本記事では、google検索でportalsによる無限スクロールを試し、portalsの可能性と現在の問題点を共有出来れば良いなと思っています。<br>portals流行ってくれ！！</p>\n<h2>portalsとはなんぞや</h2>\n<p>Webページの中に別のWebページを埋め込むためのhtml要素として、iframeがあります。portalsではiframeのように、埋め込んだWebページにシームレスに遷移することが出来ます。事前にページをロードすることが出来るので、例えば、遷移する際にページ全体が一瞬真っ白になる現象を防げます。SPAのページ遷移でも同じようなことが出来ますが、htmlの標準仕様として実装出来る点が優れていると思います。</p>\n<p>現在portalsはドラフト状態です。現在の仕様は<a href=\"https://wicg.github.io/portals/\">WICGの仕様書</a>[^1]で見れます。<br>今はChrome Canaryでしか動きませんし、まだ仕様も決まりきっていませんが、今後HTMLの標準仕様となれば、他のhtml要素と同じように一般的に使用されることが予想されます。</p>\n<p>portalsについては、<a href=\"https://blog.uskay.io/article/002-hands-on-portals\">こちらの記事</a>[^2]が詳しいです。私もこの記事でportalsを知りました。</p>\n<h2>動作の前提</h2>\n<p>今回は、以下の条件でportalsによる無限スクロールを動かします。</p>\n<ul>\n<li>portalsは現状Chrome Canaryでのみ動く。</li>\n<li>google検索でのみ動く。汎用的に動くわけでは無い。</li>\n<li>chrome拡張機能として作った。</li>\n</ul>\n<p>また、portalsを動かすにはCanary版でフラグをつけて起動する必要があります。詳しくは<a href=\"https://blog.uskay.io/article/002-hands-on-portals\">この記事</a>[^2]を参考にして下さい。<br>以下引用</p>\n<blockquote>\n<p>Mac: open -a Google\\ Chrome\\ Canary --args --enable-features=Portals<br>Windows: ショートカットを右クリック、リンク先に --args -enable-features=Portals のオプションを付けて起動。<br>Linux: Canary は Linux ではサポートされていません。代替として Chromium をご利用ください。</p>\n</blockquote>\n<h2>無限スクロールの実装</h2>\n<p>ソースコードは<a href=\"https://github.com/r-yanyo/portals-infinite-loading\">github</a>に上げています。git cloneして、Chrome Canaryに拡張機能として追加すると動かせます。</p>\n<p>主にスクロールの位置を判定して、portalの表示・非表示を行っているだけです。表示方法はちょっと工夫していて、下からニュッっと出すために、空の領域(emptyArea)をportalの上に置いています。</p>\n<pre><code class=\"language-js:script.js\">window.onload = function() {\n  // もし Portal が利用できるプラットフォームであれば...\n  if (!&#39;HTMLPortalElement&#39; in window) return alert(&#39;portalが無効です。&#39;)\n\n  // google検索でだけ動かす\n  if (!window.location.href.includes(&#39;google&#39;)) return\n\n  main()\n}\n\nfunction main() {\n  // portalをページに追加\n  nextPagePortal = document.createElement(&#39;portal&#39;)\n  nextPagePortal.classList.add(&#39;portal&#39;)\n  nextLink = document.getElementsByClassName(&#39;cur&#39;)[0].nextElementSibling\n  nextPagePortal.src = nextLink.getElementsByTagName(&#39;a&#39;)[0].href\n\n  // portalとemptyAreaをwrapする、スクロール領域\n  scrollArea = document.createElement(&#39;div&#39;)\n  scrollArea.classList.add(&#39;scroll&#39;)\n\n  // portalの表示を下にずらすためのempty領域\n  emptyArea = document.createElement(&#39;div&#39;)\n  emptyArea.classList.add(&#39;empty&#39;)\n\n  // 一番下までスクロールしたらportalがappendされる\n  window.onscroll = function() {\n    const scrollTop = document.documentElement.scrollTop || document.body.scrollTop\n    if (scrollTop &gt;= document.body.offsetHeight - window.innerHeight) {\n      document.body.appendChild(scrollArea)\n      scrollArea.appendChild(emptyArea)\n      scrollArea.appendChild(nextPagePortal)\n      scrollArea.style.display = &#39;block&#39;\n    }\n  }\n\n  scrollArea.onscroll = function() {\n    // 上に戻ったらportal非表示\n    if (this.scrollTop &lt;= 0) {\n      this.style.display = &#39;none&#39;\n    }\n    // スクロールし終えたらactivate\n    if (this.scrollTop &gt;= window.innerHeight) {\n      nextPagePortal.activate()\n    }\n  }\n}\n</code></pre>\n<pre><code class=\"language-css:style.css\">.portal {\n  width: 100vw;\n  height: 100vh;\n}\n\n.scroll {\n  position: fixed;\n  top: 0;\n  height: 100vh;\n  width: 100vw;\n  z-index: 10000;\n  overflow-y: scroll;\n}\n\n.empty {\n  height: 100vh;\n  width: 100vw;\n}\n</code></pre>\n<h2>portalsの現在の問題点</h2>\n<h3>無限に再帰する</h3>\n<p>portalは<code>src</code>属性で参照するhtmlを指定しますが、それ自身が追加されているページを指定することも可能です。<br>例えば、<code>A.html</code>に<code>&lt;portal src=&quot;A.html&quot;&gt;</code>を追加することが出来ます。すると、DOMツリーは以下のように無限に再帰します。</p>\n<pre><code class=\"language-html:A.html\">&lt;html&gt;\n  ...\n  &lt;portal src=&quot;A.html&quot;&gt;\n    #document\n      &lt;html&gt;\n        ...\n        &lt;portal src=&quot;A.html&quot;&gt;\n          #document\n            &lt;html&gt;\n              ....\n</code></pre>\n<p>上の例は自己参照ですが、相互参照（A.htmlとB.htmlがportalsで参照し合うような場合）や、今回行った無限スクロールの場合でも同じ現象が起きます。</p>\n<p>今回はこれを防ぐために、ページを一番下までスクロールしてからDOMツリーにportalを追加しています。portalsの売りはシームレスな遷移なので、初めはwindow.onloadのタイミングで追加していましたが、上記の問題にぶつかったので追加タイミングを変えました。[^4]</p>\n<p>また、これはiframeでも起きうる問題ですが、iframeでは特定回数以上の入れ子になるとストップしてくれるようです。<a href=\"%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%AB%E4%BE%9D%E3%82%8B%E3%80%82chrome%E3%81%A7%E8%A9%A6%E3%81%97%E3%81%9F%E3%81%A8%E3%81%93%E3%82%8D%E3%80%81iframe%E3%81%AF3%E5%B1%A4%E4%BB%A5%E4%B8%8A%E3%81%A7%E3%82%B9%E3%83%88%E3%83%83%E3%83%97%E3%81%99%E3%82%8B%E4%BB%95%E6%A7%98%E3%81%A0%E3%81%A3%E3%81%9F%E3%80%82%E3%81%93%E3%81%AE%E8%BE%BA%E3%82%8A%E3%81%AF%E6%B0%97%E3%81%AB%E3%81%AA%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%A7%E3%80%81WICG%E3%81%AEgithub%E3%81%A7%E8%B3%AA%E5%95%8F%E3%81%97%E3%81%A6%E3%81%BF%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82https://github.com/WICG/portals/issues/108\">^3</a></p>\n<h3>Activateした後、historyが消える</h3>\n<p>activateされた後、戻るボタンなどで前のページに戻れない。ちなみに今回実装した無限スクロールも、前のページに戻ることは出来ない。これを解決するには、仕様の変更を待つしかない、、、かな。</p>\n<h1>おわりに</h1>\n<p><strong>portals流行ってくれ！</strong></p>\n<p>[^1]: <strong>Portals</strong> <a href=\"https://wicg.github.io/portals/\">https://wicg.github.io/portals/</a><br> draft spec。暫定の仕様書。</p>\n<p>[^2]: <strong>話題の Portals を使った画面遷移 UX の未来</strong> <a href=\"https://blog.uskay.io/article/002-hands-on-portals\">https://blog.uskay.io/article/002-hands-on-portals</a><br> これを見てportalsを知りました。具体的な実装があり、非常に参考になりました。</p>\n<p>[^4]: portalsにはメッセージをやり取りするためのインターフェースが用意されています。<code>window.portalHost</code>で自身がPortal として利用されているかの判定が可能らしいです。「自身がportalsとして利用されている場合は、新たなportalをDOMツリーに追加しない」とすれば、無限に再帰するのを防げるかもしれません。</p>\n"
}